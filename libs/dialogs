#!/bin/env bash

#---------------------------------------------------------------------------------
#
#   Проект: Молот [molot]
#
#   Библиотека функций для Linux для работы
#   с текстовыми диалоговыми окнами через пакет dialog
#
#   Автор       : Железа
#   Email       : dev@zeleza.ru
#   Лицензия    : Apache Версия 2.0
#
#   Создан      : 25 февраля 2024 год
#   Обновлен    : 07 мая 2024 год
#
#---------------------------------------------------------------------------------
#   Глобальные переменные, которые используются с Dialog
#---------------------------------------------------------------------------------

SelectButtonText=Выбрать                # Метка для кнопки Select в Dialog
SaveButtonText=Сохранить                # Метка для кнопки Save в Dialog
CancelButtonText=Выйти                  # Метка для кнопки Cancel в Dialog

YesButtonText=Да                        # Метка для кнопки Yes в Dialog
NoButtonText=Нет                        # Метка для кнопки No в Dialog

DialogOk=0                              # Код возврата при нажатии на кнопку Ok или Yes в Dialog
DialogCancel=1                          # Код возврата при нажатии на кнопку Cancel или No в Dialog
DialogHelp=2                            # Код возврата при нажатии на кнопку Help в Dialog
DialogExtra=3                           # Код возврата при нажатии на кнопку Extra (между Ok и Cancel) в Dialog
DialogItemHelp=4                        # Код возврата при нажатии элемент в Help в Dialog
DialogTimeout=5                         # Код возврата при достижении установленного таймаута в Dialog
DialogError=-1                          # Код возврата при ошибке в Dialog
DialogEsc=255                           # Код возврата при нажатии на кнопку Esc в Dialog

#---------------------------------------------------------------------------------

is_button_pressed_in_menu(){
#---------------------------------------------------------------------------------
#   Убеждаемся, что была нажата клавиша любая из кнопок, а не пункт меню
#---------------------------------------------------------------------------------

    [[ "${1}" =~ ^@.* ]]
}

is_ok_yes_pressed(){
#---------------------------------------------------------------------------------
#   Убеждаемся, что была нажата клавиша Сохранить (Ok)
#---------------------------------------------------------------------------------
    [ "${1//@${DialogOk}/}" != "${1}" ] 
}

is_esc_pressed(){
#---------------------------------------------------------------------------------
#   Убеждаемся, что была нажата клавиша Выход (Cancel)
#---------------------------------------------------------------------------------

    [ "${1//@${DialogEsc}/}" != "${1}" ] 
}

is_cancel_pressed(){
#---------------------------------------------------------------------------------
#   Убеждаемся, что была нажата клавиша Выход (Cancel)
#---------------------------------------------------------------------------------

    [ "${1//@${DialogCancel}/}" != "${1}" ] 
}

is_help_pressed(){
#---------------------------------------------------------------------------------
#   Убеждаемся, что была нажата клавиша Помощь (Help)
#---------------------------------------------------------------------------------

    [ "${1//@${DialogHelp}/}" != "${1}" ] 
}

is_extra_pressed(){
#---------------------------------------------------------------------------------
#   Убеждаемся, что была нажата клавиша Extra
#---------------------------------------------------------------------------------

    [ "${1//@${DialogExtra}/}" != "${1}" ] 
}

is_item_help_pressed(){
#---------------------------------------------------------------------------------
#   Убеждаемся, что была нажата клавиша DialogItemHelp
#---------------------------------------------------------------------------------

    [ "${1//@${DialogItemHelp}/}" != "${1}" ] 
}

is_timeout_pressed(){
#---------------------------------------------------------------------------------
#   Убеждаемся, что была нажата клавиша DialogTimeout
#---------------------------------------------------------------------------------

    [ "${1//@${DialogTimeout}/}" != "${1}" ] 
}

is_error_pressed(){
#---------------------------------------------------------------------------------
#   Убеждаемся, что была нажата клавиша DialogError
#---------------------------------------------------------------------------------

    [ "${1//@${DialogError}/}" != "${1}" ] 
}

count_lines() {
#---------------------------------------------------------------------------------
# 
#   Считаем число строка в многострочной строке
#   Аргументы:
#       $1 - Многострочная строка 
# 
#---------------------------------------------------------------------------------
    local result=$(echo -e ${1} | grep -c '^')
    
    [ "${result}" -le 2 ] && {

        local multiline_text="$1"  # Многострочный текст передается первым аргументом
        local line_count=0

        # Обходим каждую строку в многострочном тексте
        while IFS= read -r line; do
            ((line_count++))      # Увеличиваем счетчик строк на 1 для каждой строки
        done <<< "$multiline_text"

        result="$line_count"        # Возвращаем количество строк
    }
    echo ${result}
}

find_max_length() {
#---------------------------------------------------------------------------------
# 
#   Возвращаем кодличество символов у самой длинной строке в многострочной строке
#   Аргументы:
#       $1 - Многострочная строка 
# 
#---------------------------------------------------------------------------------
    local input_str="$1"
    local max_length=0

    # Заменяем символы '\n' на реальные символы новой строки
    input_str=$(echo -e "$input_str")

    # Обрабатываем строку построчно
    while IFS= read -r line; do
        # Получаем длину текущей строки
        line_length=${#line}

        # Если длина текущей строки больше максимальной, обновляем max_length
        if (( line_length > max_length )); then
            max_length=$line_length
        fi
    done <<< "$input_str"

    # Выводим максимальную длину
    echo $max_length
}


show_message_dialog() {
#---------------------------------------------------------------------------------
#   Отображение сообщения в диалоговом окне, если оно есть
#   
#   Аргументы:
#       $1 - Заголовок окна сообщения 
#       $2 - Текст сообщения
#       $3 - дополнительные параметры dialog 
# 
#---------------------------------------------------------------------------------

    if [ -n "${2}" ] ; then
        local width=$(($(find_max_length "${2}") + 5))
        local hight=$(($(count_lines "${2}") + 5)) 
        dialog --colors ${3:-} --cr-wrap \
               --title "${1}" \
               --msgbox "\n${2}\n" "${hight}" "${width}" \
        2>&1 >/dev/tty
        # sleep "${timeout}"
        # kill $!
    fi
}


show_info_message(){
#---------------------------------------------------------------------------------
#   Отображаем окно с информацией без кнопок 
# 
#   Аргументы:
#       $1 - Заголовок окна
#       $2 - Текст для вывода
#       $3 - Число секунд ожидания, почле чего окно исчезнет (по умолчанию 3 сек)
#
#---------------------------------------------------------------------------------

    header="${1}"               # Заголовок окна
    mess="${2}"                 # Текст для вывода
    left="${3:-3}"              # Число секунд ожидания


    while test ${left} != 0; do

        dialog  --sleep 1 --cr-wrap --print-version \
                --title "${header}" \
                --infobox "${mess}" 10 70
        let left--

    done

}

show_error_dialog() {
#---------------------------------------------------------------------------------
#   Выводим ошибку в диалоговом окне, если оно есть
#   
#   Аргументы:
#       $1 - Текст сообщения
# 
#---------------------------------------------------------------------------------

    if [ -n "${1}" ] ; then
        local width=$(($(find_max_length "${1}") + 5))
        local hight=$(($(count_lines "${1}") + 5)) 
        dialog  --colors --cr-wrap \
                --title "\Z1ОШИБКА\Zn" \
                --aspect 6 \
                --msgbox "\n${1}\n" "${hight}" "${width}" \
        2>&1 >/dev/tty
    fi
}

show_yes_no_dialog(){
#---------------------------------------------------------------------------------
# 
#   Отображаем вопрос Да/Нет
#   $1 - Текст вопроса
#   $2 - Выбранный вариант по умолчанию: yes - Да, no - Нет (по умолчанию yes)
#   $3 - дополнительные параметры dialog
# 
#---------------------------------------------------------------------------------
    local question=${1}
    local default=${2:-yes}
    local extra=${3:-}
    

    [ -n "${question}" ] && {
        local width=$(($(find_max_length "${1}") + 5))
        local hight=$(($(count_lines "${1}") + 7)) 

        dialog --colors --cr-wrap \
            --title "\Z4ВОПРОС\Zn" \
            --default-button "${default}" \
            --yes-label "${YesButtonText}" \
            --no-label "${NoButtonText}" \
            ${extra} \
            --yesno "\n${1}\n" "${hight}" "${width}" \
            2>&1 >/dev/tty
        echo "@${?}"
    }
}

show_menu() {
    #---------------------------------------------------------------------------------
    #   Отображает меню 
    # 
    #   Аргументы:
    # 
    #   $1 - Заголовок страницы
    #   $2 - Заголовок окна
    #   $3 - Заголовок меню 
    #   $4 - Аргументы дополнительные для dialog
    #   $5 - Координаты отображения окна (auto по умолчанию)
    #   $6 - Имя массива с текстовым меню (в виде ссылки на массив)
    # 
    #   Возврат: 1. Код возврата при нажатии кнопки в виде @<код_возврата> 
    #            2. Текст или число первого столбца выбранного пункта из массива меню
    #   Пример: 
    # 
    #     local _menu=(
	# 	            1 "Поиск проекта на диске"
	# 	            2 "Клонирование проекта из Github"
	#           )
    # 
    #           choice=$(show_menu "Создание нового проекта" \
	#                       "Меню выбора " \
	#                       "\n Выберите дальнейшее действие" \
	#                       "--no-collapse --no-tags --cr-wrap --aspect 3" "auto" _menu) 
    # 
    #           case "${choice}" in
    # 
    #               @1*)    break ;;          # выход из меню при нажатии на Выход
    #               "1")    search_project ;;
    #               "2")    clone_project ;;
    #               *)    exit ;;  
    #           esac
    # 
    #---------------------------------------------------------------------------------
    local code selected
    local xyw_array result arg_array


    local page_title=${1}
    local menu_title=${2}
    local menu_act=${3}
    local dialog_args=${4}
    local xyw_str=${5}
    local -n menu_array=${6}

    # Обрабатываем дополнительные для dialog аргументы и преобразуем их в массив
    read -ra arg_array <<< "$dialog_args"

    # Обрабатываем координаты отображения dialogs и преобразуем их в массив
    if [ "${xyw_str}" = 'auto' ]; then 
        xyw_array=(0 0 0)
    else
        read -ra xyw_array <<< "${xyw_str}"
    fi 

    cmd=(dialog --cr-wrap \
            --clear "${arg_array[@]}" \
            --colors --keep-tite \
            --ok-label "${SelectButtonText}" \
            --cancel-label "${CancelButtonText}" \
            --backtitle "${page_title}" \
            --title "${menu_title}" \
            --menu "${menu_act}" "${xyw_array[@]}")

    # Возвращаем список с выбранными значениями
    selected=$("${cmd[@]}" "${menu_array[@]}" 2>&1 >/dev/tty)
    code=${?}
    [[ "${code}" == 0 ]] && result="${selected}" || result="@${code}|${selected}"
    printf "%s\n" "${result}"
}

show_select_one(){
#---------------------------------------------------------------------------------
#   Отображает список выбора с возможностью выбрать только один пункт 
#  
#   Аргументы:
# 
#   $1 - Заголовок страницы
#   $2 - Заголовок окна
#   $3 - Элемент по умолчанию
#   $4 - Экстра параметры dialog, которые начинаются с --
#   $5 - Массив списка текстовых пунктов из трех столбцов
#        1 - <возвращаемое значение>
#        2 - "описание пункта"
#        3 - off/on
# 
#   Возвращает: текст первого столбца выбранного пункта из масссива
# 
#---------------------------------------------------------------------------------
    
    local page_title menu_title default_item  
    page_title=${1}; menu_title=${2}; default_item=${3};  dialog_args=${4};
    local -n _menu_items=${5}

    # Обрабатываем дополнительные для dialogs аргументы и преобразуем их в массив
    read -ra arg_array <<< "$dialog_args"

    cmd=(dialog --clear --cr-wrap "${arg_array[@]}"  \
                --default-item "${default_item}" \
                --ok-label "${SaveButtonText}" \
                --cancel-label "${CancelButtonText}" \
                --backtitle "${page_title}" \
                --title "${menu_title}" \
                --radiolist "\nВыберите один из вариантов:" \
                0 0 0)
    choosen=$("${cmd[@]}" "${_menu_items[@]}" 2>&1 >/dev/tty)
    code=${?}; [[ "${code}" == 0 ]] && result="${choosen}" || result="@${code}"
    printf "%s" "${result}"
}



show_multy_select(){
#---------------------------------------------------------------------------------
#   Отображаем пункты множественного выбора из списка 
# 
#   Аргументы:
#       $1 - заголовок страницы на котоой отображается меню
#       $2 - заголовок окна с меню 
#       $3 - массив данных для отображенияв формате 
#            1 столбец         "возвращаемое значение"       
#            2 столбец         "описание"
#            3 столбец         "код включения/отключения"
#            
#           Примеры:
#           "'Buddy 5' 'KN-2710' 'on'" или 
#           "'Buddy 5' 'KN-2710' 'off'"
#
#   Возврат: 1. '@0' - ничего не выбрано и нажата Ok 
#            2. '@1' - ничего не выбрано и нажата Отмена
#                   при этом символ @ служит опознавательным знаком, 
#                   что вернули код нажатия клавиши 
#            3. "<массив выбранных пунктов>" - если выбрали что-либо
#       
#---------------------------------------------------------------------------------

    local page_title menu_title selected code result 
    page_title=${1}; menu_title=${2}; 
    local -n menu_items=${3}
    local dialog_args=${4:-}
    
    # Обрабатываем дополнительные для dialogs аргументы и преобразуем их в массив
    read -ra arg_array <<< "$dialog_args"

    cmd=(dialog --clear --cr-wrap "${arg_array[@]}" \
                --ok-label "${SaveButtonText}" \
                --cancel-label "${CancelButtonText}" \
                --backtitle "${page_title}" \
                --title "${menu_title}" \
                --separate-output  \
                --checklist "\nВыберите несколько вариантов:" 0 0 0)

    # Возвращаем список с выбранными значениями
    selected=$("${cmd[@]}" "${menu_items[@]}" 2>&1 >/dev/tty)

    # получаем код возврата и при отсуствии выбора отправиляем код возврата 
    code=${?}; [[ "${code}" == 0 ]] && result="${selected}" || result="@${code}|${selected}"
    printf "%s\n" "${result}" 
}


show_form(){
#---------------------------------------------------------------------------------
# 
#   Отображаем форму ввода с несколькими полями ввода
# 
#   Аргументы:
#       $1 - заголовок страницы на котоой отображается меню
#       $2 - заголовок окна с меню 
#       $3 - Массив списка текстовых пунктов из девяти столбцов
#            label - выводимое описание пункта ввода (метка)
#            y     - позиция метки по вертикали
#            x     - позиция метки по горизонтали
#            input - значение по умолчанию
#            y     - позиция пукта по вертикали 
#            x     - позиция пукта по горизонтали
#            flen  - отображаемая длинна поля ввода, сколько знаков отображать
#            ilen  - вводимая длина поля ввода, сколько всего можно ввести знаков
#            itype - тип вводимых данных: 
#                    первый бит = 1 - скрытый (для паролей)
#                    второй бит = 1 только для чтения
#
#   Возврат: 1. '@0' - ничего не выбрано и нажата Ok 
#            2. '@1' - ничего не выбрано и нажата Отмена
#                   при этом символ @ служит опознавательным знаком, 
#                   что вернули код нажатия клавиши 
#            3. "<массив выбранных пунктов>" - если выбрали что-либо
#       
#---------------------------------------------------------------------------------

    local page_title form_title selected code result  
    page_title=${1}; form_title=${2}; shift 2; 

    cmd=(dialog --clear --cr-wrap --colors \
                --backtitle "${page_title}" \
                --title "${form_title}" \
                --ok-label "${SaveButtonText}" \
                --cancel-label "${CancelButtonText}" \
                --mixedform "\n Введите данные" 0 0 0)

    # Возвращаем список с выбранными значениями
    values=$("${cmd[@]}" "${@}" 2>&1 >/dev/tty)
    # получаем код возврата и при отсуствии выбора отправиляем код возврата 
    code=${?}; [[ "${code}" == 0 ]] && result="${values}" || result="@${code}|${values[@]}"

    echo "${result}" 
}

show_input(){
#---------------------------------------------------------------------------------
# 
#   Отображает окно ввода одиночного значения
#  
#   Аргументы:
# 
#   $1 - Заголовок страницы
#   $2 - Заголовок окна
#   $3 - Описание поля (его заголовок при вводе)
#   $4 - Экстра параметры dialog, которые начинаются с --
#   $4 - Название кнопки Ok по умолчанию SaveButton
# 
#   Возвращает: текст введенного поля
# 
#---------------------------------------------------------------------------------
    local page_title menu_title default_item  
    page_title=${1}; menu_title=${2}; field_description=${3}; ok_label=${4:-${SaveButtonText}}; dialog_args=${5:-}; 
    
    # Обрабатываем дополнительные для dialogs аргументы и преобразуем их в массив
    read -ra arg_array <<< "$dialog_args"
    
    cmd=(dialog  --clear --colors --cr-wrap "${arg_array[@]}"  \
            --backtitle "${page_title}" \
	        --title "${menu_title}"  \
            --ok-label "${ok_label}" \
            --cancel-label "${CancelButtonText}" \
            --inputbox "${field_description}" 0 0 )

    choosen=$("${cmd[@]}" 2>&1 >/dev/tty)
    code=${?}; [[ "${code}" == 0 ]] && result="${choosen}" || result="@${code}"
    printf "%s" "${result}" 

}

function dialog_confirm() {
#------------------------------------------------------------------------------
#
#        Функция dialog_confirm предназначена для вывода диалога с запросом 
#        и последующим подтверждением действия.
#
#        Аргументы:
#             $1 - Текст заголовка окна
#             $2 - Текст запроса 
#             $3 - Текст для повторного подтверждения действия
#
#        Возвращает:
#             0 - если действие подтверждено
#             1 - если действие отменено
#
#        Использование:
#             dialog_confirm "Хотите удалить файл?" "Подтвердите удаление"
#
#------------------------------------------------------------------------------

    dialog --title "$1" --yesno "$2" 10 50
    if [ $? -eq 0 ]; then
        dialog --title "Подтверждение действия" --yesno "$3" 10 50
        return $?
    else
        return 1
    fi
}
